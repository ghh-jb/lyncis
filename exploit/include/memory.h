#ifndef memory_h
#define memory_h

#include <stdio.h>
#include <mach/mach.h>

#define rk32_via_port(addr, var) { \
   read(fake_port_pipe[0], (void *)fake_port, fake_port_size + fake_task_size); \
   *port_read_addr = (addr - koffsetof(proc, pid)); \
   write(fake_port_pipe[1], (void *)fake_port, fake_port_size + fake_task_size); \
   var = 0x0; \
   if (pid_for_task(pipe_fake_task_port, (int *)&var) != 0) goto done; \
}

extern kern_return_t mach_vm_read_overwrite(vm_map_read_t, mach_vm_address_t, mach_vm_size_t, mach_vm_address_t, mach_vm_size_t *);
extern kern_return_t mach_vm_allocate(vm_map_t, mach_vm_address_t *, mach_vm_size_t, int);
extern kern_return_t mach_vm_deallocate(vm_map_t, mach_vm_address_t, mach_vm_size_t);
extern kern_return_t mach_vm_write(vm_map_t, mach_vm_address_t, vm_offset_t, mach_msg_type_number_t);
extern kern_return_t mach_vm_protect(vm_map_t, mach_vm_address_t, mach_vm_size_t, boolean_t, vm_prot_t);
extern kern_return_t mach_vm_remap(vm_map_t, mach_vm_address_t *, mach_vm_size_t, mach_vm_offset_t, int, vm_map_t, mach_vm_address_t, boolean_t, vm_prot_t *, vm_prot_t *, vm_inherit_t);
extern kern_return_t mach_vm_wire(host_priv_t, vm_map_t, mach_vm_address_t, mach_vm_size_t, vm_prot_t);

void init_memory(mach_port_t tfp0);
size_t kread(uint32_t where, void *p, size_t size);
size_t kwrite(uint32_t where, const void *p, size_t size);
uint32_t kalloc(size_t size);
void kfree(uint32_t addr, size_t size);

uint8_t rk8(uint32_t addr);
uint16_t rk16(uint32_t addr);
uint32_t rk32(uint32_t addr);

void wk8(uint32_t addr, uint8_t data);
void wk16(uint32_t addr, uint16_t data);
void wk32(uint32_t addr, uint32_t data);

#endif /* memory_h */