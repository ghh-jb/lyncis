#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach/mach.h>

#include "memory.h"

static mach_port_t memory_tfp0 = MACH_PORT_NULL;

size_t kread(uint32_t where, void *p, size_t size) {
    int ret = 0;
    size_t offset = 0;
    while (offset < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - offset) chunk = size - offset;
        ret = mach_vm_read_overwrite(memory_tfp0, where + offset, chunk, (mach_vm_address_t)p + offset, &sz);
        if (ret || sz == 0) break;
        offset += sz;
    } return offset;
}

size_t kwrite(uint32_t where, const void *p, size_t size) {
    int ret = 0;
    size_t offset = 0;
    while (offset < size) {
        size_t chunk = 2048;
        if (chunk > size - offset) chunk = size - offset;
        ret = mach_vm_write(memory_tfp0, where + offset, (uint32_t)p + offset, (int)chunk);
        if (ret) break;
        offset += chunk;
    } return offset;
}

uint32_t kalloc(size_t size) {
    mach_vm_address_t addr = 0;
    if(mach_vm_allocate(memory_tfp0, &addr, size, VM_FLAGS_ANYWHERE) != 0) return 0;
    return addr;
}

void kfree(uint32_t addr, size_t size) {
    mach_vm_deallocate(memory_tfp0, (mach_vm_address_t)addr, size);
}

uint8_t rk8(uint32_t addr) {
    uint8_t value = 0;
    kread(addr, &value, 0x4);
    return value;
}

uint16_t rk16(uint32_t addr) {
    uint16_t value = 0;
    kread(addr, &value, 0x2);
    return value;
}

uint32_t rk32(uint32_t addr) {
    uint32_t value = 0;
    kread(addr, &value, 0x4);
    return value;
}

void wk8(uint32_t addr, uint8_t data) {
    kwrite(addr, &data, 0x1);
}

void wk16(uint32_t addr, uint16_t data) {
    kwrite(addr, &data, 0x2);
}

void wk32(uint32_t addr, uint32_t data) {
    kwrite(addr, &data, 0x4);
}

void init_memory(mach_port_t tfp0) {
    memory_tfp0 = tfp0;
}